{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n  var define = require('amdefine')(module, require);\n}\n\ndefine(function (require, exports, module) {\n  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\n\n  var util = require('./util'); // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n  // operating systems these days (capturing the result).\n\n\n  var REGEX_NEWLINE = /(\\r?\\n)/; // Newline character code for charCodeAt() comparisons\n\n  var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of\n  // the source-map library are loaded. This MUST NOT CHANGE across\n  // versions!\n\n  var isSourceNode = \"$$$isSourceNode$$$\";\n  /**\n   * SourceNodes provide a way to abstract over interpolating/concatenating\n   * snippets of generated JavaScript source code while maintaining the line and\n   * column information associated with the original source code.\n   *\n   * @param aLine The original line number.\n   * @param aColumn The original column number.\n   * @param aSource The original source's filename.\n   * @param aChunks Optional. An array of strings which are snippets of\n   *        generated JS, or other SourceNodes.\n   * @param aName The original identifier.\n   */\n\n  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n\n\n  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode(); // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are removed from this array, by calling `shiftNextLine`.\n\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n\n    var shiftNextLine = function () {\n      var lineContents = remainingLines.shift(); // The last line of a file might not have a newline.\n\n      var newLine = remainingLines.shift() || \"\";\n      return lineContents + newLine;\n    }; // We need to remember the position of \"remainingLines\"\n\n\n    var lastGeneratedLine = 1,\n        lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n\n    var lastMapping = null;\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          var code = \"\"; // Associate first line with \"lastMapping\"\n\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0; // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[0];\n          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code); // No more remaining code, continue\n\n          lastMapping = mapping;\n          return;\n        }\n      } // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n\n\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[0];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n\n      lastMapping = mapping;\n    }, this); // We have processed all mappings.\n\n    if (remainingLines.length > 0) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      } // and add the remaining lines without any mapping\n\n\n      node.add(remainingLines.join(\"\"));\n    } // Copy sourcesContent into SourceNode\n\n\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n      }\n    }\n  };\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n\n\n  SourceNode.prototype.add = function SourceNode_add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function (chunk) {\n        this.add(chunk);\n      }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    } else {\n      throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n    }\n\n    return this;\n  };\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n\n\n  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (var i = aChunk.length - 1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    } else {\n      throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n    }\n\n    return this;\n  };\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n\n\n  SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n    var chunk;\n\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      } else {\n        if (chunk !== '') {\n          aFn(chunk, {\n            source: this.source,\n            line: this.line,\n            column: this.column,\n            name: this.name\n          });\n        }\n      }\n    }\n  };\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n\n\n  SourceNode.prototype.join = function SourceNode_join(aSep) {\n    var newChildren;\n    var i;\n    var len = this.children.length;\n\n    if (len > 0) {\n      newChildren = [];\n\n      for (i = 0; i < len - 1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n\n    return this;\n  };\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n\n\n  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n    var lastChild = this.children[this.children.length - 1];\n\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === 'string') {\n      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    } else {\n      this.children.push(''.replace(aPattern, aReplacement));\n    }\n\n    return this;\n  };\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n\n\n  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n\n\n  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n\n\n  SourceNode.prototype.toString = function SourceNode_toString() {\n    var str = \"\";\n    this.walk(function (chunk) {\n      str += chunk;\n    });\n    return str;\n  };\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n\n\n  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n    var generated = {\n      code: \"\",\n      line: 1,\n      column: 0\n    };\n    var map = new SourceMapGenerator(aArgs);\n    var sourceMappingActive = false;\n    var lastOriginalSource = null;\n    var lastOriginalLine = null;\n    var lastOriginalColumn = null;\n    var lastOriginalName = null;\n    this.walk(function (chunk, original) {\n      generated.code += chunk;\n\n      if (original.source !== null && original.line !== null && original.column !== null) {\n        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column\n          }\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n\n      for (var idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0; // Mappings end at eol\n\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function (sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n    return {\n      code: generated.code,\n      map: map\n    };\n  };\n\n  exports.SourceNode = SourceNode;\n});","map":{"version":3,"sources":["/home/safouman/Desktop/Coding/crwn-clothing/node_modules/source-map/lib/source-map/source-node.js"],"names":["define","require","module","exports","SourceMapGenerator","util","REGEX_NEWLINE","NEWLINE_CODE","isSourceNode","SourceNode","aLine","aColumn","aSource","aChunks","aName","children","sourceContents","line","column","source","name","add","fromStringWithSourceMap","SourceNode_fromStringWithSourceMap","aGeneratedCode","aSourceMapConsumer","aRelativePath","node","remainingLines","split","shiftNextLine","lineContents","shift","newLine","lastGeneratedLine","lastGeneratedColumn","lastMapping","eachMapping","mapping","generatedLine","code","addMappingWithCode","nextLine","substr","generatedColumn","length","join","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","undefined","originalLine","originalColumn","prototype","SourceNode_add","aChunk","Array","isArray","chunk","push","TypeError","prepend","SourceNode_prepend","i","unshift","walk","SourceNode_walk","aFn","len","SourceNode_join","aSep","newChildren","replaceRight","SourceNode_replaceRight","aPattern","aReplacement","lastChild","replace","SourceNode_setSourceContent","aSourceFile","aSourceContent","toSetString","walkSourceContents","SourceNode_walkSourceContents","Object","keys","fromSetString","toString","SourceNode_toString","str","toStringWithSourceMap","SourceNode_toStringWithSourceMap","aArgs","generated","map","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","original","addMapping","idx","charCodeAt","sourceContent"],"mappings":"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","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\n  var util = require('./util');\n\n  // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n  // operating systems these days (capturing the result).\n  var REGEX_NEWLINE = /(\\r?\\n)/;\n\n  // Newline character code for charCodeAt() comparisons\n  var NEWLINE_CODE = 10;\n\n  // Private symbol for identifying `SourceNode`s when multiple versions of\n  // the source-map library are loaded. This MUST NOT CHANGE across\n  // versions!\n  var isSourceNode = \"$$$isSourceNode$$$\";\n\n  /**\n   * SourceNodes provide a way to abstract over interpolating/concatenating\n   * snippets of generated JavaScript source code while maintaining the line and\n   * column information associated with the original source code.\n   *\n   * @param aLine The original line number.\n   * @param aColumn The original column number.\n   * @param aSource The original source's filename.\n   * @param aChunks Optional. An array of strings which are snippets of\n   *        generated JS, or other SourceNodes.\n   * @param aName The original identifier.\n   */\n  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n  SourceNode.fromStringWithSourceMap =\n    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n      // The SourceNode we want to fill with the generated code\n      // and the SourceMap\n      var node = new SourceNode();\n\n      // All even indices of this array are one line of the generated code,\n      // while all odd indices are the newlines between two adjacent lines\n      // (since `REGEX_NEWLINE` captures its match).\n      // Processed fragments are removed from this array, by calling `shiftNextLine`.\n      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n      var shiftNextLine = function() {\n        var lineContents = remainingLines.shift();\n        // The last line of a file might not have a newline.\n        var newLine = remainingLines.shift() || \"\";\n        return lineContents + newLine;\n      };\n\n      // We need to remember the position of \"remainingLines\"\n      var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n      // The generate SourceNodes we need a code range.\n      // To extract it current and last mapping is used.\n      // Here we store the last mapping.\n      var lastMapping = null;\n\n      aSourceMapConsumer.eachMapping(function (mapping) {\n        if (lastMapping !== null) {\n          // We add the code from \"lastMapping\" to \"mapping\":\n          // First check if there is a new line in between.\n          if (lastGeneratedLine < mapping.generatedLine) {\n            var code = \"\";\n            // Associate first line with \"lastMapping\"\n            addMappingWithCode(lastMapping, shiftNextLine());\n            lastGeneratedLine++;\n            lastGeneratedColumn = 0;\n            // The remaining code is added without mapping\n          } else {\n            // There is no new line in between.\n            // Associate the code between \"lastGeneratedColumn\" and\n            // \"mapping.generatedColumn\" with \"lastMapping\"\n            var nextLine = remainingLines[0];\n            var code = nextLine.substr(0, mapping.generatedColumn -\n                                          lastGeneratedColumn);\n            remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                                lastGeneratedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n            addMappingWithCode(lastMapping, code);\n            // No more remaining code, continue\n            lastMapping = mapping;\n            return;\n          }\n        }\n        // We add the generated code until the first mapping\n        // to the SourceNode without any mapping.\n        // Each line is added as separate string.\n        while (lastGeneratedLine < mapping.generatedLine) {\n          node.add(shiftNextLine());\n          lastGeneratedLine++;\n        }\n        if (lastGeneratedColumn < mapping.generatedColumn) {\n          var nextLine = remainingLines[0];\n          node.add(nextLine.substr(0, mapping.generatedColumn));\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n        }\n        lastMapping = mapping;\n      }, this);\n      // We have processed all mappings.\n      if (remainingLines.length > 0) {\n        if (lastMapping) {\n          // Associate the remaining code in the current line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n        }\n        // and add the remaining lines without any mapping\n        node.add(remainingLines.join(\"\"));\n      }\n\n      // Copy sourcesContent into SourceNode\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          if (aRelativePath != null) {\n            sourceFile = util.join(aRelativePath, sourceFile);\n          }\n          node.setSourceContent(sourceFile, content);\n        }\n      });\n\n      return node;\n\n      function addMappingWithCode(mapping, code) {\n        if (mapping === null || mapping.source === undefined) {\n          node.add(code);\n        } else {\n          var source = aRelativePath\n            ? util.join(aRelativePath, mapping.source)\n            : mapping.source;\n          node.add(new SourceNode(mapping.originalLine,\n                                  mapping.originalColumn,\n                                  source,\n                                  code,\n                                  mapping.name));\n        }\n      }\n    };\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  SourceNode.prototype.add = function SourceNode_add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function (chunk) {\n        this.add(chunk);\n      }, this);\n    }\n    else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    }\n    else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  };\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (var i = aChunk.length-1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    }\n    else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    }\n    else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  };\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n    var chunk;\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      }\n      else {\n        if (chunk !== '') {\n          aFn(chunk, { source: this.source,\n                       line: this.line,\n                       column: this.column,\n                       name: this.name });\n        }\n      }\n    }\n  };\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  SourceNode.prototype.join = function SourceNode_join(aSep) {\n    var newChildren;\n    var i;\n    var len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len-1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  };\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n    var lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    }\n    else if (typeof lastChild === 'string') {\n      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    }\n    else {\n      this.children.push(''.replace(aPattern, aReplacement));\n    }\n    return this;\n  };\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  SourceNode.prototype.setSourceContent =\n    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n    };\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  SourceNode.prototype.walkSourceContents =\n    function SourceNode_walkSourceContents(aFn) {\n      for (var i = 0, len = this.children.length; i < len; i++) {\n        if (this.children[i][isSourceNode]) {\n          this.children[i].walkSourceContents(aFn);\n        }\n      }\n\n      var sources = Object.keys(this.sourceContents);\n      for (var i = 0, len = sources.length; i < len; i++) {\n        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n      }\n    };\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  SourceNode.prototype.toString = function SourceNode_toString() {\n    var str = \"\";\n    this.walk(function (chunk) {\n      str += chunk;\n    });\n    return str;\n  };\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n    var generated = {\n      code: \"\",\n      line: 1,\n      column: 0\n    };\n    var map = new SourceMapGenerator(aArgs);\n    var sourceMappingActive = false;\n    var lastOriginalSource = null;\n    var lastOriginalLine = null;\n    var lastOriginalColumn = null;\n    var lastOriginalName = null;\n    this.walk(function (chunk, original) {\n      generated.code += chunk;\n      if (original.source !== null\n          && original.line !== null\n          && original.column !== null) {\n        if(lastOriginalSource !== original.source\n           || lastOriginalLine !== original.line\n           || lastOriginalColumn !== original.column\n           || lastOriginalName !== original.name) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column\n          }\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      for (var idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0;\n          // Mappings end at eol\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function (sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n\n    return { code: generated.code, map: map };\n  };\n\n  exports.SourceNode = SourceNode;\n\n});\n"]},"metadata":{},"sourceType":"script"}